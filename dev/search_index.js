var documenterSearchIndex = {"docs":
[{"location":"special_distributions/#Special-Distributions","page":"Special Distributions","title":"Special Distributions","text":"","category":"section"},{"location":"special_distributions/","page":"Special Distributions","title":"Special Distributions","text":"Differ from the behavior of Distributions.jl.","category":"page"},{"location":"special_distributions/","page":"Special Distributions","title":"Special Distributions","text":"Pages   = [\"special_distributions.md\"]","category":"page"},{"location":"special_distributions/","page":"Special Distributions","title":"Special Distributions","text":"Modules = [KernelDistributions]\nPages = [\"CircularUniform.jl\", \"SmoothExponential.jl\", \"TailUniform.jl\"]","category":"page"},{"location":"special_distributions/#KernelDistributions.Circular","page":"Special Distributions","title":"KernelDistributions.Circular","text":"Circular\n\nTransform ℝ → [0,2π)\n\n\n\n\n\n","category":"type"},{"location":"special_distributions/#KernelDistributions.CircularUniform","page":"Special Distributions","title":"KernelDistributions.CircularUniform","text":"CircularUniform\n\nGenerates uniform random numbers ∈ [0,2π]. If the lower/upper bound is exceeded the value continues at the other bound (2π+0.1=0.1).\n\n\n\n\n\n","category":"type"},{"location":"special_distributions/#Bijectors.logabsdetjac-Tuple{Circular, Any}","page":"Special Distributions","title":"Bijectors.logabsdetjac","text":"logabsdetjac(Circular, x)\n\nmod2pi will not be zero for n2π, thus the discontinuity will not be reached. Thus, the log Jacobian is always 0. \n\n\n\n\n\n","category":"method"},{"location":"special_distributions/#Bijectors.transform-Tuple{Bijectors.Inverse{Circular}, Any}","page":"Special Distributions","title":"Bijectors.transform","text":"transform(Circular, y)\n\nUses mod2pi to transform ℝ to [0,2π].\n\n\n\n\n\n","category":"method"},{"location":"special_distributions/#Bijectors.transform-Tuple{Circular, Any}","page":"Special Distributions","title":"Bijectors.transform","text":"transform(Circular, x)\n\nTransform from [0,2π] to ℝ. In theory inverse of mod does not exist, in practice the same value is returned, since [0,2π] ∈ ℝ\n\n\n\n\n\n","category":"method"},{"location":"special_distributions/#KernelDistributions.SmoothExponential","page":"Special Distributions","title":"KernelDistributions.SmoothExponential","text":"SmoothExponential(min, max, β, σ)\n\nSmooth truncated exponential distribution by convolving the exponential with a normal distribution: Smooth = Exp ⋆ Normal This results in smooth min and max limits and a definition on ℝ instead of ℝ⁺\n\nDoes not support truncated of Distributions.jl since it is a smooth truncation of the exponential distribution.\n\n\n\n\n\n","category":"type"},{"location":"special_distributions/#KernelDistributions.TailUniform","page":"Special Distributions","title":"KernelDistributions.TailUniform","text":"TailUniform(min, max)\n\nActs like a uniform distribution of [min,max] but ignores outliers and always returns 1/(max-min) as probability.\n\n\n\n\n\n","category":"type"},{"location":"quaternion_distributions/#Quaternion-Distributions","page":"Quaternion Distributions","title":"Quaternion Distributions","text":"","category":"section"},{"location":"quaternion_distributions/","page":"Quaternion Distributions","title":"Quaternion Distributions","text":"Sample truly uniform from quaternions and robust implementations for small normally distributed quaternion perturbations.","category":"page"},{"location":"quaternion_distributions/","page":"Quaternion Distributions","title":"Quaternion Distributions","text":"Pages   = [\"quaternion_distributions.md\"]","category":"page"},{"location":"quaternion_distributions/","page":"Quaternion Distributions","title":"Quaternion Distributions","text":"Modules = [KernelDistributions]\nPages = [\"QuaternionUniform.jl\", \"QuaternionPerturbation.jl\"]","category":"page"},{"location":"quaternion_distributions/#KernelDistributions.QuaternionUniform","page":"Quaternion Distributions","title":"KernelDistributions.QuaternionUniform","text":"QuaternionUniform\n\nAllows true uniform sampling of 3D rotations on CPU & GPU (CUDA).\n\n\n\n\n\n","category":"type"},{"location":"quaternion_distributions/#KernelDistributions.nonzero_sign-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Quaternion Distributions","title":"KernelDistributions.nonzero_sign","text":"nonzero_sign(q)\n\nCompared to the implementation in Quaternions.jl, this implementation does not return a Quaternion with (0,0,0,0) but the identity with (1,0,0,0). Eq. (44) in J. Sola, „Quaternion kinematics for the error-state KF“.\n\n\n\n\n\n","category":"method"},{"location":"quaternion_distributions/#KernelDistributions.:⊕-Tuple{Quaternion, Any}","page":"Quaternion Distributions","title":"KernelDistributions.:⊕","text":"⊕(q, θ)\n\n'The ‘plus’ operator [qs = qr ⊕ θ] : SO(3) × R3 → SO(3) produces an element S of SO(3) which is the result of composing a reference element R of SO(3) with a (often small) rotation. This rotation is specified by a vector of θ ∈ R3 in the vector space tangent [...]' (eq. 158, Sola 2012)\n\n\n\n\n\n","category":"method"},{"location":"quaternion_distributions/#KernelDistributions.:⊖-Tuple{Quaternion, Quaternion}","page":"Quaternion Distributions","title":"KernelDistributions.:⊖","text":"⊖(qs, qr)\n\n'The ‘minus’ operator [θ = qs ⊖ qr] : SO(3) × SO(3) → R3 is the inverse of [qs = qr ⊕ θ]. It returns the vectorial angular difference θ ∈ R3 between two elements of SO(3). This difference is expressed in the vector space tangent to the reference element [...]' (eq. 161, Sola 2012)\n\n\n\n\n\n","category":"method"},{"location":"quaternion_distributions/#KernelDistributions.exp_map-Tuple{Any, Any, Any}","page":"Quaternion Distributions","title":"KernelDistributions.exp_map","text":"exp_map(x, y, z)\n\nConvert an axis-angle rotation vector to a Quaternion (formerly qrotation in Quaternions.jl, Sola 2012)). Exponential for quaternions can be reformulated to the exponential map using (eq. 46, Sola 2012)).\n\n\n\n\n\n","category":"method"},{"location":"quaternion_distributions/#KernelDistributions.log_map-Tuple{Quaternion}","page":"Quaternion Distributions","title":"KernelDistributions.log_map","text":"log_map(q)\n\nConvert a Quaternion to an axis angle rotation vector. Exponential for quaternions can be reformulated to the exponential map using (eq. 46, Sola 2012) - log similar.\n\n\n\n\n\n","category":"method"},{"location":"quaternion_distributions/#KernelDistributions.outer_product-Union{Tuple{Quaternion{T}}, Tuple{T}} where T","page":"Quaternion Distributions","title":"KernelDistributions.outer_product","text":"outer_product(q)\n\nInterprets q as vector and calculates q * q'.\n\n\n\n\n\n","category":"method"},{"location":"quaternion_distributions/#Statistics.cov-Union{Tuple{AbstractVector{<:Quaternion{T}}}, Tuple{T}, Tuple{AbstractVector{<:Quaternion{T}}, StatsBase.AbstractWeights}, Tuple{AbstractVector{<:Quaternion{T}}, StatsBase.AbstractWeights, Int64}} where T","page":"Quaternion Distributions","title":"Statistics.cov","text":"cov(x::AbstractVector{<:Quaternion}, w::AbstractWeights, dims::Int; corrected=false)\n\nFor particle filters use analytic / reliability weights which describe an importance of each observation. Compatibility with matrix function by ignoring dims.\n\n\n\n\n\n","category":"method"},{"location":"quaternion_distributions/#Statistics.mean-Tuple{AbstractArray{<:Quaternion}, StatsBase.AbstractWeights}","page":"Quaternion Distributions","title":"Statistics.mean","text":"mean(q::AbstractVector{<:Quaternion}, w::AbstractWeights)\n\nCalculate the weighted mean Quaternion via eigenvalue decomposition. Based on \"Averaging Quaternions\", Markley et al. 2007.\n\n\n\n\n\n","category":"method"},{"location":"quaternion_distributions/#StatsBase.mean_and_cov","page":"Quaternion Distributions","title":"StatsBase.mean_and_cov","text":"mean_and_cov(x::AbstractVector{<:Quaternion}, w::AbstractWeights, dims::Int; corrected=false)\n\nFor particle filters use analytic / reliability weights which describe an importance of each observation. Compatibility with matrix function by ignoring dims.\n\n\n\n\n\n","category":"function"},{"location":"basic_distributions/#Basic-Distributions","page":"Basic Distributions","title":"Basic Distributions","text":"","category":"section"},{"location":"basic_distributions/","page":"Basic Distributions","title":"Basic Distributions","text":"These distributions behave the same way as the ones from Distributions.jl. However, as described in KernelDistributions.jl, scalars are always sampled on the CPU even if a CUDA.RNG is provided. They are named accordingly with Kernel<distribution name> prefaced.","category":"page"},{"location":"basic_distributions/","page":"Basic Distributions","title":"Basic Distributions","text":"Pages   = [\"basics_distributions.md\"]","category":"page"},{"location":"basic_distributions/","page":"Basic Distributions","title":"Basic Distributions","text":"BinaryMixture\nKernelDirac\nKernelExponential\nKernelNormal\nKernelUniform","category":"page"},{"location":"basic_distributions/#KernelDistributions.BinaryMixture","page":"Basic Distributions","title":"KernelDistributions.BinaryMixture","text":"BinaryMixture(dist_1, dist_2, weight_1, weight_2)\n\nMixture model of two distributions optimized for calculations in the logarithmic domain. Weights are automatically normalized and transformed to log domain in inner constructor.\n\n\n\n\n\n","category":"type"},{"location":"basic_distributions/#KernelDistributions.KernelDirac","page":"Basic Distributions","title":"KernelDistributions.KernelDirac","text":"KernelDirac(value)\n\nType stable implementation of a Dirac distribution which has all it's mass at the value\n\n\n\n\n\n","category":"type"},{"location":"basic_distributions/#KernelDistributions.KernelExponential","page":"Basic Distributions","title":"KernelDistributions.KernelExponential","text":"KernelExponential(β)\n\nType stable implementation of an (negative) Exponential distribution. Uses the scale parameter β so the pdf is defined as: inv(β)*exp(inv(β)).\n\n\n\n\n\n","category":"type"},{"location":"basic_distributions/#KernelDistributions.KernelNormal","page":"Basic Distributions","title":"KernelDistributions.KernelNormal","text":"KernelNormal(μ, σ)\n\nType stable implementation of a Normal distribution. Parameterized by the mean μ and standard deviation σ.\n\n\n\n\n\n","category":"type"},{"location":"basic_distributions/#KernelDistributions.KernelUniform","page":"Basic Distributions","title":"KernelDistributions.KernelUniform","text":"KernelUniform(min, max)\n\nType stable implementation of a Uniform distribution. Parameterized by the support [min,max]. If the value is outside the support, logdensityof returns -Inf (alternative TailUniform).\n\n\n\n\n\n","category":"type"},{"location":"#KernelDistributions.jl","page":"KernelDistributions.jl","title":"KernelDistributions.jl","text":"","category":"section"},{"location":"","page":"KernelDistributions.jl","title":"KernelDistributions.jl","text":"Modules = [KernelDistributions]\nPages   = [\"KernelDistributions.jl\"]","category":"page"},{"location":"#KernelDistributions.KernelDistributions","page":"KernelDistributions.jl","title":"KernelDistributions.KernelDistributions","text":"MeasureTheory.jl is what I have used because of the nicer interface until now, but all the type are not isbits and can not be used on the GPU. Distributions.jl is pretty close but not perfect for the execution on the GPU:\n\nMostly type stable\nMixtures a quirky\nUniform is not strongly typed resulting in Float64 calculations all the time.\n\nHere, I provide stripped-down Distributions which are isbitstype, strongly typed and thus support execution on the GPU. KernelDistributions offer the following interface functions:\n\nDensityInterface.logdensityof(dist::KernelDistribution, x)\nRandom.rand!(rng, dist::KernelDistribution, A)\nBase.rand(rng, dist::KernelDistribution, dims...)\nBase.eltype(::Type{<:AbstractKernelDistribution}): Number format of the distribution, e.g. Float16\n\nThe Interface requires the following to be implemented:\n\nBijectors.bijector(d): Bijector\nrand_kernel(rng, dist::MyKernelDistribution{T})::T generate a single random number from the distribution\nDistributions.logpdf(dist::MyKernelDistribution{T}, x)::T evaluate the normalized logdensity\nBase.maximum(d), Base.minimum(d), Distributions.insupport(d): Determine the support of the distribution\nDistributions.logcdf(d, x), Distributions.invlogcdf(d, x): Support for Truncated{D}\n\nMost of the time Float64 precision is not required, especially for GPU computations. Thus, I default to Float32, mostly for memory capacity reasons.\n\n\n\n\n\n","category":"module"},{"location":"#KernelDistributions.AbstractKernelDistribution","page":"KernelDistributions.jl","title":"KernelDistributions.AbstractKernelDistribution","text":"AbstractKernelDistribution{T,S<:ValueSupport} <: UnivariateDistribution{S}\n\nOverrides the following behaviors of Distributions.jl:\n\nlogdensityof broadcasts logpdf\nbijector for an array of distributions broadcasts bijector\nArrays are generated RNG specific (default: Array, CUDA.RNG: CuArray) and filled via broadcasting\n\n\n\n\n\n","category":"type"},{"location":"","page":"KernelDistributions.jl","title":"KernelDistributions.jl","text":"@license BSD-3 https://opensource.org/licenses/BSD-3-Clause\nCopyright (c) 2022, Institute of Automatic Control - RWTH Aachen University\nAll rights reserved. ","category":"page"}]
}
